//! Trust-based isolation level selection.
//!
//! The policy engine selects the appropriate isolation level for each
//! skill based on its trust tier. This implements the industry-standard
//! isolation hierarchy:
//!
//! | Trust tier | Isolation level | Backend |
//! |-----------|----------------|---------|
//! | `Trusted` | L1 (container/noop) | NoopBackend or Docker |
//! | `Internal` | L2 (gVisor/Linux NS) | LinuxNamespaceBackend |
//! | `Untrusted` | L3 (microVM) | Docker Sandbox or Firecracker |
//! | `LlmGenerated` | L3 (microVM) | Docker Sandbox or Firecracker |

use std::fmt;

use super::{
    BackendPreference, DockerSandboxBackend, FirecrackerBackend, LinuxNamespaceBackend,
    NoopBackend, SandboxBackend, select_backend,
};

/// Trust level assigned to a skill.
///
/// Determines the minimum isolation boundary required for execution.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum TrustTier {
    /// First-party code, fully audited. Minimal isolation.
    Trusted,
    /// Internal tools, partially audited. Container-grade isolation.
    Internal,
    /// Third-party or unaudited code. MicroVM isolation required.
    Untrusted,
    /// Code generated by an LLM. Always requires strongest isolation.
    LlmGenerated,
}

impl TrustTier {
    /// Parse a trust tier from a string.
    pub fn from_str_loose(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "trusted" => Some(Self::Trusted),
            "internal" => Some(Self::Internal),
            "untrusted" => Some(Self::Untrusted),
            "llm-generated" | "llm_generated" | "llmgenerated" => Some(Self::LlmGenerated),
            _ => None,
        }
    }
}

impl fmt::Display for TrustTier {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TrustTier::Trusted => write!(f, "trusted"),
            TrustTier::Internal => write!(f, "internal"),
            TrustTier::Untrusted => write!(f, "untrusted"),
            TrustTier::LlmGenerated => write!(f, "llm-generated"),
        }
    }
}

/// Isolation level (corresponds to the industry L1–L3 hierarchy).
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum IsolationLevel {
    /// L1: Container / no-op — shared kernel, cgroup/namespace isolation.
    L1Container,
    /// L2: Linux namespaces with seccomp + landlock, or gVisor.
    L2Namespace,
    /// L3: MicroVM — own kernel, KVM/hypervisor boundary.
    L3MicroVm,
}

impl IsolationLevel {
    /// Parse an isolation level from a string.
    pub fn from_str_loose(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "l1" | "l1-container" | "l1_container" | "container" => Some(Self::L1Container),
            "l2" | "l2-namespace" | "l2_namespace" | "namespace" | "gvisor" => {
                Some(Self::L2Namespace)
            }
            "l3" | "l3-microvm" | "l3_microvm" | "microvm" | "vm" => Some(Self::L3MicroVm),
            _ => None,
        }
    }
}

impl fmt::Display for IsolationLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            IsolationLevel::L1Container => write!(f, "L1 (container)"),
            IsolationLevel::L2Namespace => write!(f, "L2 (namespace)"),
            IsolationLevel::L3MicroVm => write!(f, "L3 (microVM)"),
        }
    }
}

/// Selects the appropriate isolation backend based on trust tier.
///
/// The selector maps trust tiers to isolation levels, then resolves
/// each level to the best available backend on the current platform.
pub struct TrustBasedSelector {
    /// Override: force a specific backend regardless of trust tier.
    forced_backend: Option<BackendPreference>,
}

impl TrustBasedSelector {
    /// Create a new trust-based selector with default mappings.
    pub fn new() -> Self {
        Self {
            forced_backend: None,
        }
    }

    /// Override: always use a specific backend regardless of trust tier.
    pub fn with_forced_backend(mut self, pref: BackendPreference) -> Self {
        self.forced_backend = Some(pref);
        self
    }

    /// Map a trust tier to its minimum required isolation level.
    pub fn required_level(tier: TrustTier) -> IsolationLevel {
        match tier {
            TrustTier::Trusted => IsolationLevel::L1Container,
            TrustTier::Internal => IsolationLevel::L2Namespace,
            TrustTier::Untrusted | TrustTier::LlmGenerated => IsolationLevel::L3MicroVm,
        }
    }

    /// Select the best available backend for the given trust tier.
    ///
    /// If a forced backend is configured, returns that regardless of tier.
    /// Otherwise, selects the appropriate backend for the trust level:
    ///
    /// - L1: NoopBackend (dev) or Docker (prod)
    /// - L2: LinuxNamespaceBackend
    /// - L3: Docker Sandbox or Firecracker
    pub fn select(&self, tier: TrustTier) -> Box<dyn SandboxBackend> {
        // Forced override
        if let Some(pref) = &self.forced_backend {
            return select_backend(pref);
        }

        let level = Self::required_level(tier);

        match level {
            IsolationLevel::L1Container => {
                // Prefer Docker for L1 if available, else noop
                let docker = DockerSandboxBackend::default();
                if docker.available() {
                    Box::new(docker)
                } else {
                    Box::new(NoopBackend)
                }
            }
            IsolationLevel::L2Namespace => {
                let ns = LinuxNamespaceBackend::new();
                if ns.available() {
                    Box::new(ns)
                } else {
                    // Fall back to Docker
                    let docker = DockerSandboxBackend::default();
                    if docker.available() {
                        Box::new(docker)
                    } else {
                        tracing::warn!(
                            tier = %tier,
                            level = %level,
                            "No L2 backend available, falling back to noop"
                        );
                        Box::new(NoopBackend)
                    }
                }
            }
            IsolationLevel::L3MicroVm => {
                // Prefer Firecracker for strongest isolation
                let fc = FirecrackerBackend::default();
                if fc.available() {
                    return Box::new(fc);
                }
                // Docker Sandbox as fallback
                let docker = DockerSandboxBackend::default();
                if docker.available() {
                    return Box::new(docker);
                }
                // Linux NS as last resort
                let ns = LinuxNamespaceBackend::new();
                if ns.available() {
                    tracing::warn!(
                        tier = %tier,
                        "No L3 backend available, downgrading to L2 namespace isolation"
                    );
                    return Box::new(ns);
                }
                tracing::error!(
                    tier = %tier,
                    "No isolation backend available for untrusted code — using noop!"
                );
                Box::new(NoopBackend)
            }
        }
    }
}

impl Default for TrustBasedSelector {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_trust_tier_display() {
        assert_eq!(TrustTier::Trusted.to_string(), "trusted");
        assert_eq!(TrustTier::Internal.to_string(), "internal");
        assert_eq!(TrustTier::Untrusted.to_string(), "untrusted");
        assert_eq!(TrustTier::LlmGenerated.to_string(), "llm-generated");
    }

    #[test]
    fn test_trust_tier_parse() {
        assert_eq!(
            TrustTier::from_str_loose("trusted"),
            Some(TrustTier::Trusted)
        );
        assert_eq!(
            TrustTier::from_str_loose("INTERNAL"),
            Some(TrustTier::Internal)
        );
        assert_eq!(
            TrustTier::from_str_loose("untrusted"),
            Some(TrustTier::Untrusted)
        );
        assert_eq!(
            TrustTier::from_str_loose("llm-generated"),
            Some(TrustTier::LlmGenerated)
        );
        assert_eq!(
            TrustTier::from_str_loose("llm_generated"),
            Some(TrustTier::LlmGenerated)
        );
        assert_eq!(TrustTier::from_str_loose("invalid"), None);
    }

    #[test]
    fn test_isolation_level_display() {
        assert_eq!(IsolationLevel::L1Container.to_string(), "L1 (container)");
        assert_eq!(IsolationLevel::L2Namespace.to_string(), "L2 (namespace)");
        assert_eq!(IsolationLevel::L3MicroVm.to_string(), "L3 (microVM)");
    }

    #[test]
    fn test_isolation_level_parse() {
        assert_eq!(
            IsolationLevel::from_str_loose("l1"),
            Some(IsolationLevel::L1Container)
        );
        assert_eq!(
            IsolationLevel::from_str_loose("container"),
            Some(IsolationLevel::L1Container)
        );
        assert_eq!(
            IsolationLevel::from_str_loose("l2"),
            Some(IsolationLevel::L2Namespace)
        );
        assert_eq!(
            IsolationLevel::from_str_loose("gvisor"),
            Some(IsolationLevel::L2Namespace)
        );
        assert_eq!(
            IsolationLevel::from_str_loose("l3"),
            Some(IsolationLevel::L3MicroVm)
        );
        assert_eq!(
            IsolationLevel::from_str_loose("microvm"),
            Some(IsolationLevel::L3MicroVm)
        );
        assert_eq!(IsolationLevel::from_str_loose("invalid"), None);
    }

    #[test]
    fn test_isolation_level_ordering() {
        assert!(IsolationLevel::L1Container < IsolationLevel::L2Namespace);
        assert!(IsolationLevel::L2Namespace < IsolationLevel::L3MicroVm);
    }

    #[test]
    fn test_required_level_mapping() {
        assert_eq!(
            TrustBasedSelector::required_level(TrustTier::Trusted),
            IsolationLevel::L1Container
        );
        assert_eq!(
            TrustBasedSelector::required_level(TrustTier::Internal),
            IsolationLevel::L2Namespace
        );
        assert_eq!(
            TrustBasedSelector::required_level(TrustTier::Untrusted),
            IsolationLevel::L3MicroVm
        );
        assert_eq!(
            TrustBasedSelector::required_level(TrustTier::LlmGenerated),
            IsolationLevel::L3MicroVm
        );
    }

    #[test]
    fn test_trust_based_selector_returns_backend() {
        let selector = TrustBasedSelector::new();

        // All tiers should return some backend
        let b1 = selector.select(TrustTier::Trusted);
        assert!(!b1.name().is_empty());

        let b2 = selector.select(TrustTier::Internal);
        assert!(!b2.name().is_empty());

        let b3 = selector.select(TrustTier::Untrusted);
        assert!(!b3.name().is_empty());

        let b4 = selector.select(TrustTier::LlmGenerated);
        assert!(!b4.name().is_empty());
    }

    #[test]
    fn test_forced_backend_override() {
        let selector = TrustBasedSelector::new().with_forced_backend(BackendPreference::Noop);

        // Even for untrusted code, forced noop should be used
        let backend = selector.select(TrustTier::Untrusted);
        assert_eq!(backend.name(), "noop");
    }
}
